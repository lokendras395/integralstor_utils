from integralstor_utils import command, db, config

"""
All share info and user access to share info is stored in the db. The smb.conf is always generated off of this db. So this is the master source
and can be used to regenerate the conf files if they are messed up.
"""


def update_auth_method(security):
    """Update the currently set authentication method in the db. """
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        cl = []
        if not d:
            #Insert a default entry before they modify the settings..
            cl.append(["insert into samba_global_common (id, workgroup, netbios_name, security, include_homes_section) values (?, ?, ?, ?, ?)",
                   (1, 'workgroup', 'netbios_name', security, True,)])
        else:
            cl.append(
                ["update samba_global_common set security='%s' where id=1" % security])
        platform, err = config.get_platform()
        if err:
            raise Exception(err)
        if platform and platform == 'gridcell':
            cl.append(["delete from samba_valid_users"])
        ret, err = db.execute_iud(db_path, cl)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error changing authentication method : %s' % str(e)
    else:
        return True, None


def get_auth_settings():
    """Get the current authentication settings from the db."""
    d = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        d, err = db.get_single_row(
            db_path, "select * from samba_global_common where id=1")
        if err:
            raise Exception(err)
        if d and 'security' in d and d['security'] == "ads":
            d1, err = db.get_single_row(
                db_path, "select * from samba_global_ad where id=1")
            if err:
                raise Exception(err)
            if d1:
                d.update(d1)
    except Exception, e:
        return None, 'Error loading authentication settings : %s' % str(e)
    else:
        return d, None


def update_auth_settings(d):
    """Update the authentication settings in the db to what has been passed in the dict"""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        auth_settings, err = get_auth_settings()
        if err:
            raise Exception(err)
        if not auth_settings:
            cmd = ["insert into samba_global_common (id, workgroup, netbios_name, security, include_homes_section) values (?, ?, ?, ?, ?)",
                   (1, d["workgroup"], d["netbios_name"], d["security"], True,)]
        else:
            cmd = ["update samba_global_common set workgroup=?, netbios_name=?, security=?, include_homes_section=? where id = ?",
                   (d["workgroup"], d["netbios_name"], d["security"], True, 1,)]
        cmd_list = []
        cmd_list.append(cmd)
        if d["security"] == "ads":
            d1, err = db.get_single_row(
                db_path, "select * from samba_global_ad")
            if err:
                raise Exception(err)
            if d1:
                cmd = ["update samba_global_ad set realm=?, password_server=?, ad_schema_mode=?, id_map_min=?, id_map_max=?, password_server_ip=?  where id = ?",
                       (d["realm"], d["password_server"], 'rfc2307', 16777216, 33554431, d["password_server_ip"], 1, )]
                cmd_list.append(cmd)
            else:
                cmd = ["insert into samba_global_ad (realm, password_server, ad_schema_mode, id_map_min, id_map_max, password_server_ip, id) values(?,?,?,?,?,?,?)", (
                    d["realm"], d["password_server"], 'rfc2307', 16777216, 33554431, d["password_server_ip"], 1,)]
                cmd_list.append(cmd)
        # print cmd_list
        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error saving authentication settings : %s' % str(e)
    else:
        return True, None


def delete_auth_settings():
    """ Delete all authentication settings from the db. """
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        ret, err = db.execute_iud(db_path, [["delete from samba_auth "]])
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error deleting authentication settings : %s' % str(e)
    else:
        return True, None


def get_shares_list():
    """Load the list of currently created shares from the db. """
    l = []
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        l, err = db.get_multiple_rows(db_path, 'select * from samba_shares')
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error loading CIFS shares list : %s' % str(e)
    else:
        return l, None


def get_shares_on_subpath(subpath):
    """This is used to find all shares on a particular sub path and is used to make sure we dont delete that path if shares exist."""
    l = []
    try:
        if not subpath.startswith('/'):
            subpath = '/%s' % subpath
        if not subpath.endswith('/'):
            subpath += '/'
        share_list, err = get_shares_list()
        if err:
            raise Exception(err)
        if share_list:
            for share in share_list:
                share_path = share['path']
                if not share_path.endswith('/'):
                    share_path += '/'
                if subpath in share_path:
                    l.append(share)
    except Exception, e:
        return None, 'Error retrieving shares on subpath: %s' % str(e)
    else:
        return l, None


def get_share_info(mode, index):
    """Get the info for a share either based on name or by db id"""
    d = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        query = None
        if mode == "by_id":
            query = "select * from samba_shares where share_id = %s" % index
        else:
            query = "select * from samba_shares where name = %s" % index
        d, err = db.get_single_row(db_path, query)
        if err:
            raise Exception(err)

    except Exception, e:
        return None, 'Error loading CIFS share information : %s' % str(e)
    else:
        return d, None


def delete_share(share_id):
    """Delete a share from the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)

        cmd_list = []
        cmd_list.append(
            ["delete from samba_shares where share_id=?", (share_id, )])
        if platform and platform == 'gridcell':
            cmd_list.append(
                ["delete from samba_valid_users where share_id=?", (share_id, )])

        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error deleting CIFS share : %s' % str(e)
    else:
        return True, None


def delete_all_shares():
    """Delete all shares from the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)

        cmd_list = []
        cmd_list.append(["delete from samba_shares "])
        if platform and platform == 'gridcell':
            cmd_list.append(["delete from samba_valid_users "])

        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)
    except Exception, e:
        return False, 'Error deleting all CIFS shares : %s' % str(e)
    else:
        return True, None


def update_share(share_id, name, comment, guest_ok, read_only, path, browseable, users, groups, hosts_allow=None, hosts_deny=None):
    """Used to update the information about an existing share in the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)

        cmd_list = []
        cmd_list.append(["update samba_shares set comment=?, read_only=?, guest_ok=?, browseable=?, hosts_allow=?, hosts_deny=? where share_id=?",
                         (comment, read_only, guest_ok, browseable, hosts_allow, hosts_deny, share_id, )])
        if platform and platform == 'gridcell':
            cmd_list.append(
                ["delete from samba_valid_users where share_id=?", (share_id, )])
            if not guest_ok:
                if users:
                    for user in users:
                        cmd_list.append(
                            ["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, False, user,)])
                if groups:
                    for group in groups:
                        cmd_list.append(
                            ["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, True, group,)])
        ret, err = db.execute_iud(db_path, cmd_list)
        if err:
            raise Exception(err)

    except Exception, e:
        return False, 'Error saving CIFS share : %s' % str(e)
    else:
        return True, None


def create_share(name, comment, guest_ok, read_only, path, display_path, browseable, users, groups, vol, hosts_allow=None, hosts_deny=None):
    """Create a new share in the db."""
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        platform, err = config.get_platform()
        if err:
            raise Exception(err)
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        if not d:
            raise Exception(
                "Authentication settings not set. Please set authentication settings before creating shares.")
        shl, err = get_shares_list()
        if err:
            raise Exception(err)
        if shl:
            for sh in shl:
                if sh["name"] == name:
                    raise Exception("A share with that name already exists")
        share_id, err = db.execute_iud(db_path, [["insert into samba_shares (name, vol, path, display_path, comment, read_only, guest_ok, browseable, share_id, hosts_allow, hosts_deny) values (?,?, ?,?,?,?,?,?,NULL,?,?)", (
            name, vol, path, display_path, comment, read_only, guest_ok, browseable, hosts_allow, hosts_deny,)]], True)
        if err:
            raise Exception(err)
        # print share_id, err
        if platform and platform == 'gridcell':
            if not guest_ok:
                cmd_list = []
                if users:
                    for user in users:
                        cmd_list.append(
                            ["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, False, user,)])
                if groups:
                    for group in groups:
                        cmd_list.append(
                            ["insert into samba_valid_users (id, share_id, grp, name) values (NULL,?,?,?)", (share_id, True, group,)])
                ret, err = db.execute_iud(db_path, cmd_list, True)
                if err:
                    raise Exception(err)

    except Exception, e:
        return False, 'Error creating CIFS share : %s' % str(e)
    else:
        return True, None


def get_ad_users_or_groups(type):
    """Issue an active directory command that gets all users and groups to display in share creation/editing."""
    o = None
    try:
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        workgroup = d['workgroup']
        if type and type == "users":
            o, err = command.get_command_output(
                'wbinfo -u --domain=%s' % workgroup)
            if err:
                raise Exception(err)
        elif type and type == "groups":
            o, err = command.get_command_output(
                'wbinfo -g --domain=%s' % workgroup)
            if err:
                raise Exception(err)
        else:
            raise Exception("Unknown type specified.")
        # print '%s - '%type, o

    except Exception, e:
        return None, 'Error retrieving Active Directory Users/Groups : %s' % str(e)
    else:
        return o, None


def generate_global_header(f):
    """Generates the common global header . integralstor/gridcell may add parts that are unique to them."""
    try:
        if not f:
            raise Exception('No file handle passed')
        f.write("; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
        f.write("[global]\n")
    except Exception, e:
        return False, 'Error generating CIFS configuration file, global header section : %s' % str(e)
    else:
        return True, None


def generate_common_global_section(f, d, extra_global_param_lines=None):
    """Generates the common global section. integralstor/gridcell may add parts that are unique to them."""
    try:
        # print d
        if not f:
            raise Exception('No file handle passed')
        f.write("  log file = /var/log/smblog.vfs\n")
        #f.write("  log level=5\n")
        f.write("  log level=1 acls:3 locking:3\n")
        f.write("  oplocks=yes\n")
        f.write("  ea support=yes\n")
        f.write("  level2 oplocks=yes\n")
        f.write("  posix locking=no\n")
        f.write("  load printers = no\n")
        f.write("  printing = bsd\n")
        f.write("  printcap name = /dev/null\n")
        f.write("  disable spoolss = yes\n")
        f.write("  map to guest = bad user\n")
        f.write("  idmap config *:backend = tdb\n")
        if 'workgroup' in d:
            f.write("  workgroup = %s\n" % d["workgroup"].upper())
        #f.write("  netbios name = %s\n"%d["netbios_name"].upper())
        if d["security"] == "ads":
            f.write("  security = ADS\n")
            f.write("  preferred master = no\n")
            f.write("  encrypt passwords = yes\n")
            f.write("  winbind enum users  = yes\n")
            f.write("  winbind enum groups = yes\n")
            f.write("  winbind use default domain = yes\n")
            f.write("  winbind nested groups = yes\n")
            f.write("  winbind separator = +\n")
            f.write("  local master = no\n")
            f.write("  domain master = no\n")
            f.write("  wins proxy = no\n")
            f.write("  dns proxy = no\n")
            f.write("  winbind nss info = rfc2307\n")
            f.write("  winbind trusted domains only = no\n")
            f.write("  winbind refresh tickets = yes\n")
            f.write("  map untrusted to domain = Yes\n")
            if 'realm' in d:
                f.write("  realm = %s\n" % d["realm"].upper())
            if 'workgroup' in d:
                f.write("  idmap config %s:default = yes\n" %
                        d["workgroup"].upper())
                f.write("  idmap config %s:backend = ad\n" %
                        d["workgroup"].upper())
                if 'ad_schema_mode' in d:
                    f.write("  idmap config %s:schema_mode = %s\n" %
                            (d["workgroup"].upper(), d["ad_schema_mode"]))
            #f.write("  idmap config %s:range = %d-%d\n"%(d["workgroup"].upper(), d["id_map_min"], d["id_map_max"]))
                f.write("  idmap config %s:range = 16777216-33554431\n" %
                        d["workgroup"].upper())
                f.write("  idmap config %s:base_rid = 0\n" %
                        d["workgroup"].upper())
        else:
            f.write("  idmap config *:range = 16777216-33554431\n")
        if extra_global_param_lines:
            for line in extra_global_param_lines:
                f.write("  %s\n" % line)
    except Exception, e:
        return False, 'Error generating CIFS configuration file, common global section : %s' % str(e)
    else:
        return True, None


def generate_share_header(f, share_name):
    """Generate the header section for a share in smb.conf."""
    try:
        if not f:
            raise Exception('No file handle passed')
        f.write("\n[%s]\n" % share_name)
    except Exception, e:
        return False, 'Error generating CIFS configuration file, shares header section : %s' % str(e)
    else:
        return True, None


def generate_common_share_body(f, workgroup, path, read_only, browseable, comment, extra_share_param_lines=None, hosts_allow=None, hosts_deny=None):
    """Generate the share body in smb.conf. Only generates the parts that are common to integralstor and gridcell."""
    try:
        if not f:
            raise Exception('No file handle passed')
        if comment:
            f.write("  comment = %s\n" % comment)
        f.write("  path = %s\n" % path)
        f.write("  create mask = 0660\n")
        f.write("  kernel share modes = no\n")
        f.write("  directory mask = 0770\n")
        if hosts_allow:
            f.write('  hosts allow = %s\n' % hosts_allow)
        if hosts_deny:
            f.write('  hosts deny = %s\n' % hosts_deny)

        if read_only:
            t = "yes"
        else:
            t = "no"
        f.write("  read only = %s\n" % t)

        if browseable:
            t = "yes"
        else:
            t = "no"
        f.write("  browseable = %s\n" % t)
        if extra_share_param_lines:
            for line in extra_share_param_lines:
                f.write("  %s\n" % line)
    except Exception, e:
        return False, 'Error generating CIFS configuration file, common share body section : %s' % str(e)
    else:
        return True, None


def generate_krb5_conf():
    """Generate the kerberos conf file used for active directory authentication."""
    try:
        d, err = get_auth_settings()
        if err:
            raise Exception(err)
        krb5_conf_path, err = config.get_krb5_conf_path()
        if err:
            raise Exception(err)
        with open("%s/krb5.conf" % krb5_conf_path, "w") as f:
            f.write(
                "; This file has been programatically generated by the IntegralStor system. Do not modify it manually!\n\n")
            f.write("[logging]\n")
            f.write("  default = FILE:/var/log/krb5libs.log\n")
            f.write("  kdc = FILE:/var/log/krb5kdc.log\n")
            f.write("  admin_server = FILE:/var/log/kadmind.log\n")

            f.write("\n[libdefaults]\n")
            f.write("  default_realm = %s\n" % d["realm"].upper())
            f.write("\n[realms]\n")
            f.write("    %s = {\n" % d["realm"].upper())
            f.write("    kdc = %s\n" % d["password_server"])
            f.write("    admin_server = %s\n" % d["password_server"])
            f.write("  }\n")
            f.write("\n[domain_realm]\n")
            f.write("  .%s = %s\n" % (d["realm"].lower(), d["realm"].upper()))
            f.write("  %s = %s\n" % (d["realm"].lower(), d["realm"].upper()))
    except Exception, e:
        return False, 'Error generating kerberos configuration : %s' % str(e)
    else:
        return True, None


def main():
    print get_shares_on_subpath('/fractalio/ds1')


if __name__ == '__main__':
    main()

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
